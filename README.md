# visual_polarization

This is a collection of little scripts I wrote up (all essentially different versions of representing the same math) to help visualize how the electric field vector changes as a function of z (position in the direction of propagation, i.e. where you are on the wave) for different kinds of polarization.

***Volume 2 of the 3D version,*** $\verb|see_polarization_3D_vol2.py|$, ***is the pièce de résistance of this entire repository.*** The rest are genuinely made obsolete by its existence, but for the sake of completeness (and to document my failures and triumphs) they will remain. It includes user input (kind of, you have the change the values in the python file iself, not very fancy lol), and produces two plots. One shows the frozen ($t=0$) wave in 3D, with arrows pointing in the direction that the wave is travelling, as well as a projection back into 2D of the full wave. The second is just the 2D projection, with all the 3D "fluff" removed. It also tells you explicitly whether the polarization is left or right handed, in cases where that is applicable.

The original $\verb|(see_polarization.py)|$ has the "full functionality" (of this now deprecated version), including a GUI and user input. I do not know how to make a standalone executable (I tried, but it ended up giving me ~1 GB of dependencies that needed to be distributed alongside the .exe, which feels like it defeats the point). The downside is that it requires the user to have Python installed on their machine, as well as 3 libraries (numpy, matplotlib, and dearpygui). pip makes this easy to do, but I wish that burden didn't fall on the user.

Volume 2 is reduced rather significantly, most importantly by removing the GUI components, and as such removing any dependency on the dearpygui package, which is far and away the least common. Anyone running this will likely have numpy and matplotlib installed already. The downside is that the values of E_x, E_y, phi_x, and phi_y must be changed manually in the code, without a cool GUI. I could have the input be done through the console, but that's ultimately not much prettier than just doing in the .py file itself.

The 3D notebook version creates just the 3D graph from Volume 2, but it is also a notebook, which some may find easier to deal with.

Beware that most online Python compilers don't have $\verb|matplotlib.animate|$, even if they do have $\verb|matplotlib.pyplot|$. As such, they will show a blank plot for the original and 2D volume 2 programs, since they don't have the necessary library to deal with the animation. This has been considered, but ultimately I feel the animation is so crucial to these program having any merit that it couldn't be left out or replaced with a static image. Unfortunately, that means you'll have to download the code (or copy it) into your own IDE, or a compiler of your choice.


Also note that some simplifications and assumptions have been made. From the general form of polarized light, $\mathbf{E}(z,t) = \left(E_x e^{i\phi_x}\hat{x} + E_y e^{i\phi_y}\hat{y}\right)e^{i(kz-\omega t)} = |E_{\mathrm{eff}}|\left(A\hat{x} + Be^{i\delta} \hat{y} \right)e^{i(kz - \omega t + \phi_x)}$, time is frozen at $t=\tfrac{\phi_x}{\omega}$. This means the animation shows where different points of the wave are at a given time. If we were to imagine collapsing the wave in the $z$-direction, such that its projection in 2D were in the $xy$-plane at $z=0$, the animation shows where each part of the wave would hit. Also, since $k =\tfrac{2\pi}{\lambda}$, we set the wavelength equal to $2\pi$ so $k$ would equal 1. While this is obviously ridiculous for visibile light it makes the math easier, and we're suppressing all the $z$ information by projecting into 2D, so the resulting graph is the same whether we use the arbitrary $k=1$ or if we calculate $k$ based off some visible wavelength. This does make a meaningful difference in the 3D version though, as we are no longer suppressing the $z$ axis. For the 3D one, we calculate $k$ based on a wavelength of $520 \mathrm{nm}$ (and make the plot green to match). For convenience, as our 3D programs don't show the scaling on any axis (since the ultimate goal is to get a feel
for the polarization geometry, not get explicit values for the strength of the electric field anywhere) we have set $E_\mathrm{eff}$ equal to 1.
