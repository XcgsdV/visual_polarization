# visual_polarization

This is a collection of little scripts I wrote up (all essentially different versions of representing the same math) to help visualize how the electric field vector changes as a function of z (position in the direction of propagation, i.e. where you are on the wave) for different kinds of polarization.

The original version $\verb|(see_polarization.py)|$ has the "full functionality," including a GUI and user input. I do not know how to make a standalone executable (I tried, but it ended up giving me ~1 GB of dependencies that needed to be distributed alongside the .exe, which feels like it defeats the point). The downside is that it requires the user to have Python installed on their machine, as well as 3 libraries (numpy, matplotlib, and dearpygui). pip makes this easy to do, but I wish that burden didn't fall on the user.

Volume 2 is reduced rather significantly, most importantly by removing the GUI components, and as such removing any dependency on the dearpygui package, which is far and away the least common. Anyone running this, i.e. Zach and maybe Dr. Young, will have numpy and matplotlib installed already. The downside is that the values of E_x, E_y, phi_x, and phi_y must be changed manually in the code, without a cool GUI. I could have the input be done through the console, but that's ultimately not much prettier than just doing in the .py file itself.

The 3D notebook version creates a 3D graph, rather than an animation. This evolved out of the desire to include the figures in my lab report, since GIFs are difficult to get to "play nice" with LaTeX. There is a .py version in the works.

Beware that most online Python compilers don't have $\verb|matplotlib.animate|$, even if they do have $\verb|matplotlib.pyplot|$. As such, they will show a blank plot, since they don't have the necessary library to deal with the animation. This has been considered, but ultimately I feel the animation is so crucial to this program having any merit that it couldn't be left out or replaced with a static image. Unfortunately, this means you'll have to download the code (or copy it) into your own IDE, or a compiler of your choice.


Also note that some simplifications and assumptions have been made. From the general form of polarized light, $\mathbf{E}(z,t) = \left(E_x e^{i\phi_x}\hat{x} + E_y e^{i\phi_y}\hat{y}\right)e^{i(kz-\omega t)} = |E_{\mathrm{eff}}|\left(A\hat{x} + Be^{i\delta} \hat{y} \right)e^{i(kz - \omega t + \phi_x)}$, time is frozen at $t=\tfrac{\phi_x}{\omega}$. This means the animation shows where different points of the wave are at a given time. If we were to imagine collapsing the wave in the $z$-direction, such that its projection in 2D were in the $xy$-plane at $z=0$, the animation shows where each part of the wave would hit. Also, since $k =\tfrac{2\pi}{\lambda}$, we set the wavelength equal to $2\pi$ so $k$ would equal 1. While this is obviously ridiculous for visibile light it makes the math easier, and we're suppressing all the $z$ information by projecting into 2D, so the resulting graph is the same whether we use the arbitrary $k=1$ or if we calculate $k$ based off some visible wavelength. This does make a meaningful difference in the 3D version though, as we are no longer suppressing the $z$ axis. For the 3D one, we calculate $k$ based on a wavelength of $520 \mathmrm{nm}$ (and make the plot green to match).
